precision mediump float;

attribute vec3 VertexPosition;
attribute vec3 VertexNormal;
attribute vec2 InstanceCoord;

varying vec3 CameraNormal;
varying vec3 CameraLightDirection;

uniform sampler2D Rotations;
uniform sampler2D Offsets;

uniform sampler2D PositionsX;
uniform sampler2D PositionsY;
uniform sampler2D PositionsZ;

uniform mat4 Projection;
uniform mat4 View;

uniform vec3 Size;
uniform vec3 MiddleTranslation; //test

vec4 quat_mul(vec4 q1, vec4 q2) {
	return vec4(
		q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
		q1.w * q2.w - dot(q1.xyz, q2.xyz)
	);
}

vec3 rotate_vector(vec3 v, vec4 r) {
	vec4 r_c = r * vec4(-1, -1, -1, 1);
	return quat_mul(r, quat_mul(vec4(v, 0), r_c)).xyz;
}

vec4 color_to_quat(vec4 color) {
    return color * (255.0 / 127.0) - 1.0;
}

vec3 color_to_offset(vec4 color) {

    float len = color.w * 2.0;

    return (color.xyz * (255.0 / 127.0) - 1.0) * len;
}

#define precision 1000.0

float color_to_float(vec4 color) {

  return
    (
    color.r * (255.0 / precision) +
    color.g * (256.0 * 255.0 / precision) +
    color.b * (256.0 * 256.0 * 255.0 / precision)
    ) * (color.a * 2.0 - 1.0);
}

vec3 get_position(vec2 coord) {

    return vec3
    (
        color_to_float(texture2D(PositionsX, coord)),
        color_to_float(texture2D(PositionsY, coord)),
        color_to_float(texture2D(PositionsZ, coord))
    );
}

void main()
{
    vec4 Rotation = color_to_quat(texture2D(Rotations, InstanceCoord));

    vec3 RootPosition = get_position(InstanceCoord);
    vec3 Offset = color_to_offset(texture2D(Offsets, InstanceCoord));

    vec3 Position = RootPosition + Offset;

    vec3 WorldVertexPosition = rotate_vector(VertexPosition * Size + MiddleTranslation, Rotation) + Position;

    gl_Position = Projection * View * vec4(WorldVertexPosition, 1);

    CameraLightDirection = -(View * vec4(WorldVertexPosition, 1)).xyz;
    CameraNormal = (View * vec4(rotate_vector(VertexNormal, Rotation), 0)).xyz;
}